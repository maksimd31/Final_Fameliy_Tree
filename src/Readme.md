# Урок 1. Принципы ООП: Инкапсуляция, наследование, полиморфизм

> В этой ветке хранится решение домашнего задания №1 и №2

### Домашнее задание №1

Реализовать, с учетом ооп подхода, приложение
Для проведения исследований с генеалогическим древом.
Идея: описать некоторое количество компонент, например:
модель человека и модель семейного дерева для хранения связей и отношений между людьми: родитель, ребёнок - классика, но
можно подумать и про отношение, брат, свекровь, сестра и т. д.
У дерева обязательно реализовать метод добавления нового человека в семейное дерево, поиск человека по имени и вывод
всех людей из дерева.
У человека можно реализовать методы вывода всех сестер или всех детей.
Проект сдать либо в виде репозитория либо в виде PullRequest к проекту: https://github.com/Liberate520/homeWork
Если делаете PR, то в качестве ответа укажите ссылку на конкретный PR
Инструкция на то как сделать PR https://youtu.be/veMDnBt30pk
По вопросам домашки писать @Liberate520
Обязательно пробуем свои силы, в дальнейшем будем этот проект развивать

> Получил оценку хорошо, И решил все переделать. Хотелось бы получить отлично!
> По возможности пересмотрел все лекции ООП с Каменецким и поняли что он недостаточно объясняет хорошо для моего
> понимания.
> Пересмотрел все семинары стало понятнее.
> В общем посмотрел что-то на ютубчике + книга head fist "Изучаем Java" помогла разъяснить что да как и
> переделал первое Д/З с пояснениями действий и с описанием что для чего.

### Домашнее задание №2

Урок 2. Принципы ООП Абстракция и интерфейсы. Пример проектирования
В проекте с гениалогическим древом подумайте и используйте интерфейсы.
Дополнить проект методами записи в файл и чтения из файла. Для этого создать отдельный класс и реализовать в нем
нужные методы. Для данного класса сделайте интерфейс, который и используйте в своей программе. Например, в классе дерева
в качестве аргумента метода save передавайте не конкретный класс, а объект интерфейса, с помощью которого и будет
происходить запись. Пример работы с интерфейсом Serialazable можно найти в материалах к уроку.

> Получил оценку удовлетворительно, и решил все переделать. Хотелось бы получить отлично!
> Продолжил пересматривать материал по ООП, сделал выводы и все переделал, с пояснением в комментарий.
> Переделал методы добавления людей в древо.
> Переделал интерфейсы включая интерфейс Serialazable.

### Домашнее задание №3

Урок 3. Некоторые стандартные интерфейсы Java и примеры их использования
В проекте с деревом реализовать интерфейс Iterable для дерева.
Создать методы сортировки списка людей перед выводом, например по имени или по дате рождения

> Продолжил пересматривать материал по ООП, сделал выводы и все переделал, с пояснением в комментарий.
> Добавил Iterable + различные виды сортировок.
>

### Домашнее задание №4

Урок 4. ООП: Обобщения. ч1
Продолжаем грейдить наш проект с гениологическим древом. Изменить древо, сделать класс параметизированным. Продумать
класс общения с пользователем, сделать набор команд, для операций над деревом

> Создал отдельный класс кэширования с использованием дженериков.(что бы не ломать готовые классы)
> реализовал его чтение через main в 18 строке.
>
> Создаю отдельный класс для общения пользователем CommunicationWithUsers (не успел доделать но план реализации написал)
> Сделал описание каждой функции и старые пометил @как устаревшая функция
> Переделал и добавил новые варианты сортировки в Service
> Добавил новые улучшение методы, лямда выражения и указатели к ним
> Старался использовать верблюжий стиль программирования.
>
>
> убрал все лишнее из main и раскидал по файлам.
> Начал делать сразу 2 варианта вывода класса общения с пользователем, не закончил не один)
> Прописал try/catch в виде обработки ошибки, для замены else для switch
>
> Старался все по максимуму упорядочить, навести порядок, сделал код ревью))

### Урок 5. От простого к практике

Продолжаем работать с проектом дерева. Попытаться структурировать список команд. Если не создан отдельный класс под
общение с пользователем, то создать. Все процессы связанные с выводом на консоль или чтением с консоли необходимо
делать только в одном специализированном классе (например View). Сам этот класс может общаться со многими классами
позволяющих ему реализовать эти две задачи. Можно также разбить команды на отдельные классы, связанные интерфейсом (
смотри пример в конце семинара). Если все и так уже реализовано в таком виде, тоnпросто сдаем работу)


> Переделал класс CommunicationWithUsers и назвал его View там отдельный switch с красивой записью
> также начал реализовывать все варианты ранее написанных методов объединив их вызов в один метод (Хотя правильнее
> наверное выбрать один метод а остальные удалить, и переделать методы все под один)
>
> Добавил дополнительное описание к методам
>
> В классе Designer_Human сделал полную чистку и оставил только конструкторы + перегрузку toString, все методы
> перенес в Femily_Tree.
>
> В класс Femily_Tree перенес все методы связанные с добавлением/поиска перенес сюда. + итераторы,
> провел чистку убрал все лишнее, добавил описание. (добавил новые методы добавления в методе addHumanNewHomework5 в
> 172 строке не могу понять как можно по другому написать строчку if (newDate != null && newDate.equals(end)) //Пытался
> сделать по разному только так сработало
)
>
>
> Класс Service раскидал по другим классам поскольку в нем творилась солянка,и сложно было понять для чего этот класс  
> раскидал его на отдельные классы с описанием PrintMetods и SortClass
>
> В Main остались только методы вызова, все остальное раскидал по присущим их классам(но так и не смог разобратся
> как в mine убрать вызов экземпляра класса или почему не срабатывает простой вызов например View view;) в общем
> хочу как то упорядочи вызов экземпляра класса.
>
>
>
>

### Домашнее задание №6

Рефакторинг и\или оптимизация проекта предыдущего дз с учетом теоретических основ SOLID’а
Или создание нового проекта "Календарь": задача создать календарь в котором есть возможность делать записи на
определенный день. Работа через консоль. Должна быть реализована возможность просмотра календаря, просмотра записей на
определенный день, добавление записей (например "в 14:00 стоматолог"). Реализована возможность сохранения календаря в
файл и восстановление из файла. Этот проект должен быть выполнен также с учетом принципов SOLID’а

> Решение домашнего задания
> 1. (SPR) Принципы единой ответственности (Убрал все божественные классы. У каждого класса одно назначение)
> 2. (OSP) Принцип открытости закрытости (Показано на примере VIVI.Print, класс закрыт для изменения но открыт для
     > модификации )
> 3. (LSP) Принципы барбыры лиска (При наследовании не изменял родителя )
> 4. (ISP) Принципы разделение интерфейсов (Разделил все интерфейсы на более узкоспециализированные )
> 5. (DIP) Принцип инверсия зависимости(Делал прослойки в виде интерфейса)
> Оптимизировал проект!
> 1. Переделал все использованные в древе методаы по принципам solid. прикрутил визуальный интерфейс JOptionPane, 
     > Рассуждения о д/з в package VIVI/ViewNewTest 
> 2. Полносью передел клас view (сделал его по принципам solid с интерфейсами и отдельными кнопками package Command )
> 3. Поработал над инкапсуляцией. 
> 4. Разложил все по директориям. 
> 5. Переименовал переменные/классы для лучшей читаемости, убрал почти все не использованные методы (ну почти все, 
     > остальные жалко)
> 6. Начал прерделывать все  scannerЫ  на JOptionPane (Код стал короче) Доделаю в итоговом проекте. 
>
> ### Домашнее задание №7 
Необходимо реализовать свой проект на любом языке программирования.
Проект с деревом или календарь (описание смотри в предыдущем уроке)
> Решение домашнего задания
> 1. Удалил лишние методы оставил наиболее эффективные (тем самым сделал проект более читабельным, Код стал меньше) 
> 2. Переделал все scannerЫ на JOptionPane (Код стал короче)
> 3. Удалил все лишние методы и классы 
> 4. Поработал над инкапсуляцией еще лучше
> 5. В Классе ViewNew -> Зациклил вюшку для обработки повторений, выбор был между исключением ошибки, но тогда я бы не 
> смог перепрыгнуть в начало цила при отработке блока else. Поэтому выбрал делать через бесконечный for, можно Можно 
> было использовать и while, но пришлось бы много прописывать break. Поменял все условные операторы на switch 
     > поскольку уловные операторы срабатывали не корректно. 
> 6. Созданный блок с вопросом о повторения действия прикрутил к каждому методу. Пробовал этот блок запихнуть, в 
     > интерфейс реализовать его в отдельном классе, вызвать его тут и перегрузить (Ничего не вышло) поэтому 
     > прописал в каждом методе. Тут проблема в том что строки continue outer; и break outer; не давали запихнуть 
     > их в метод поскольку им нужно какое то значение. если прописывать null то в дальнейшем я не могу его 
     > использовать. Идея была такая создать интерфейс реализовать его в отдельном классе, вызвать интерфейс/класс и 
     > перегрузить его. но ничего не вышло 
> 7. Добавил toLowerCase для исключения ошибки ввода по регистру.
> 8. Добавил интерфейс IConverted, Метод конвертирует все строки с заглавной буквы, он нужен для правильного ввода с 
     > клавиатуры: людей/родителей/детей тем самым список будет всегда одинаковым. + При поиске по людей как бы не 
     > вводил в консоль пользователь метод IConverted поправит и выдаст правильный ответ. (некая защита от дурака)
> 9. Переделал все методы (В один стиль, в некоторых пришлось изменить логику, где то добавил функционал где то 
     > обрезал)
> 

